import { IndexedNumber } from "../data/IndexedNumber";
import { FullStepResult } from "../data/stepResults/FullStepResult";
import { StepKind, StepKindHelper } from "../data/stepResults/StepKind";
import { StepResult } from "../data/stepResults/StepResult";

/**
 * A class for storing temporary data during indexing of an array of numbers into an array of IndexedNumbers.
 *
 * @see {@link IndexedNumber}
 */
class TemporaryIndexedNumber {
	/**
	 * @see {@link IndexedNumber} for parameter descriptions as they're identical.
	 */
	public constructor(
		public readonly id: number,
		public readonly value: number,
		public index: number | null
	) { }

	/**
	 * Freezes the temporary indexed number into an IndexedNumber instance.
	 *
	 * @returns The IndexedNumber instance created from this temporary indexed number.
	 *
	 * @see {@link IndexedNumber}
	 */
	public freeze(): IndexedNumber {
		return new IndexedNumber(this.id, this.value, this.index);
	}
};

/**
 * A class for storing indexing data during the indexing of an array of numbers into an array of IndexedNumbers.
 * This class is used to index values in the array that have the same value and index them in the context of other same-value elements.
 *
 * @see {@link IndexedNumber}
 */
class IndexingData {
	/**
	 * @param lastUsedIndex - The last used index for an associated value.
	 * @param firstNumber - The first number with the associated value, for backward assigning of index when a number with the same value is found.
	 */
	public constructor(
		public lastUsedIndex: number,
		public readonly firstNumber: TemporaryIndexedNumber
	) { }
}



/**
 * A state of highlight of an element in an array.
 */
export const enum HighlightState {
	Selected,
	OrderCorrect,
	OrderSwapped
};



/**
 * A class representing a sorting algorithm.
 */
export abstract class SortingAlgorithm {
	/**
	 * The input array of the algorithm.
	 */
	private input: Array<IndexedNumber>;

	/**
	 * The current working version of the input array of the algorithm.
	 */
	protected current: Array<IndexedNumber>;

	/**
	 * The final step result of the algorithm.
	 */
	private finalStepResult: FullStepResult | null;

	/**
	 * The generator for generating the algorithm's steps.
	 */
	private generator: Generator<StepResult>;

	/**
	 * @param input - The input array for the algorithm.
	 */
	protected constructor(input: number[]) {
		this.input = this.indexInput(input);
		this.current = this.input.slice();
		this.finalStepResult = null;

		this.generator = this.stepForwardInternal();
	}

	/**
	 * Sets the input array for the algorithm.
	 *
	 * @param input - The input array for the algorithm.
	 */
	public setInput(input: number[]): void {
		this.input = this.indexInput(input);

		this.reset();
	}

	/**
	 * Indexes an array of numbers.
	 *
	 * @param input - The input array to index.
	 *
	 * @returns The input array, indexed as an array of IndexedNumber.
	 *
	 * @see {@link IndexedNumber}
	 */
	private indexInput(input: number[]): IndexedNumber[] {
		let indexes = new Map<number, IndexingData>();
		let result = new Array<TemporaryIndexedNumber>();
		let idCounter = 0;

		for (const num of input) {
			let indexData = indexes.get(num);
			let indexedNumber: TemporaryIndexedNumber;

			if (indexData == undefined) {
				indexedNumber = new TemporaryIndexedNumber(idCounter, num, null);
				indexes.set(num, new IndexingData(1, indexedNumber));
			} else {
				if (indexData.lastUsedIndex == 1) {
					indexData.firstNumber.index = 1;
				}

				indexData.lastUsedIndex++;

				indexedNumber = new TemporaryIndexedNumber(idCounter, num, indexData.lastUsedIndex);
			}

			result.push(indexedNumber);
			idCounter++;
		}

		return result.map(value => value.freeze());
	}

	/**
	 * Resets the algorithm.
	 *
	 * @returns The initial step of the algorithm.
	 */
	public reset(): FullStepResult {
		this.current = this.input.slice();
		this.finalStepResult = null;

		this.resetInternal();

		this.generator = this.stepForwardInternal();

		return this.getInitialStepResult();
	}

	/**
	 * Checks if the algorithm has completed.
	 *
	 * @returns True if the algorithm has completed, false otherwise.
	 */
	public isCompleted(): boolean {
		return this.finalStepResult != null;
	}

	/**
	 * Steps the algorithm forward by one step.
	 * Equivalent to calling stepForward(StepKind.Code).
	 *
	 * @returns The step result generated by the step of the algorithm.
	 */
	public stepForward(): StepResult;
	/**
	 * Steps the algorithm forward by one code step.
	 *
	 * @returns The step result generated by the step of the algorithm.
	 */
	public stepForward(kind: StepKind.Code): StepResult;
	/**
	 * Steps the algorithm forward by one full step or one sub-step.
	 *
	 * @param kind - The kind of step to take.
	 *
	 * @returns The step results generated by the steps of the algorithm until the first step of the desired kind was reached.
	 *
	 * @see {@link StepKind}
	 */
	public stepForward(kind: StepKind.Sub | StepKind.Full): StepResult[];
	/**
	 * Steps the algorithm forward by one step.
	 *
	 * @param kind - The kind of step to take. Defaults to StepKind.Code.
	 *
	 * @returns The step results generated by the steps of the algorithm until the first step of the desired kind was reached.
	 * 			If the desired kind is StepKind.Code, only one step is always taken anyway so only that one step is returned.
	 *
	 * @see {@link StepKind}
	 * @see {@link StepResult}
	 */
	public stepForward(kind: StepKind = StepKind.Code): StepResult | StepResult[] {
		if (this.finalStepResult != null)
			return kind == StepKind.Code ? this.finalStepResult : [this.finalStepResult];

		let targetIndex = StepKindHelper.getHierarchicalIndex(kind);
		let results = new Array<StepResult>();
		let lastResult: StepResult;

		do {
			lastResult = this.generator.next().value as StepResult;
			results.push(lastResult);
		} while (StepKindHelper.getHierarchicalIndex(lastResult) < targetIndex);

		if (lastResult instanceof FullStepResult && lastResult.final)
			this.finalStepResult = lastResult as FullStepResult;

		if (kind == StepKind.Code) {
			if (results.length > 1)
				throw new Error("Code step returned more than 1 StepResult");

			return lastResult;
		}

		return results;
	}

	/**
	 * Swaps two elements in the current array.
	 *
	 * @param indexA - The index of the first element to swap.
	 * @param indexB - The index of the second element to swap.
	 */
	protected swapCurrent(indexA: number, indexB: number): void {
		let tmp = this.current[indexA];
		this.current[indexA] = this.current[indexB];
		this.current[indexB] = tmp;
	}



	/**
	 * The internal implementation of stepping the algorithm forward.
	 * This method should be overridden by the algorithm implementation.
	 *
	 * @returns A generator for generating the steps of the algorithm.
	 *
	 * @see {@link StepResult}
	 * @see {@link FullStepResult}
	 * @see {@link CodeStepResult}
	 */
	protected abstract stepForwardInternal(): Generator<StepResult>;

	/**
	 * The internal implementation of resetting the algorithm.
	 * This method should be overridden by the algorithm implementation and is called after the parent SortingAlgorithm finishes it's reset.
	 */
	protected abstract resetInternal(): void;



	/**
	 * Retrieves the initial step result of the algorithm.
	 *
	 * @returns The initial step result of the algorithm.
	 */
	public abstract getInitialStepResult(): FullStepResult;

	/**
	 * Retrieves the pseudocode of the algorithm.
	 *
	 * @returns The pseudocode of the algorithm.
	 */
	public abstract getPseudocode(): string[];
}