import { SortingAlgorithm } from "../sorts/SortingAlgorithm";
import { StepResultCollection } from "../data/collections/StepResultCollection";
import { StepKind } from "../data/stepResults/StepKind";
import { ContinuousControlController } from "./ContinuousControlController";
import { StepDisplayHandler } from "../visualization/rendering/StepDisplayHandler";
import { PageColors } from "../visualization/colors/PageColors";
import { ColorMap } from "../visualization/colors/ColorMap";
import { DebuggerController } from "./DebuggerController";
import { StepKindController } from "./StepKindController";
import { InterfaceAction, InterfaceActionGroup, InterfaceActionData } from "../keyboard/InterfaceAction";
import { HtmlSvgDisplayHandler } from "../visualization/rendering/html/HtmlSvgDisplayHandler";
import { supportsRange, SvgRenderer } from "../visualization/rendering/SvgRenderer";
import { StepAction, StepController } from "./StepController";
import { VisualizationOptionsController } from "./VisualizationOptionsController";

/**
 * The PlayerController class for managing the interaction between the user interface and the sorting algorithm.
 * It handles user inputs, maintains correct state of the simulator-related UI elements and controls the flow of the sorting algorithm.
 */
export class PlayerController {
	/**
	 * A collection of step results generated by the sorting algorithm.
	 * Used as a memory, to allow easy stepping backwards and to navigate through the steps of the sorting algorithm easily.
	 */
	private steps: StepResultCollection;

	/**
	 * The current color map being used for the UI.
	 */
	private currentColorMap: ColorMap;

	/**
	 * Indicates whether the sorting algorithms is currently playing (continuously stepping forward).
	 */
	public get playing(): boolean {
		return this.continuousControls.playing;
	}

	/**
	 * Indicates whether a text field is currently focused.
	 * Used for the purposes of rejecting keyboard events when a text field is focused.
	 */
	public get textFieldFocused(): boolean {
		return window.document.activeElement == this.continuousControls.periodInput;
	}

	/**
	 * @param algorithm - The sorting algorithm to be controlled.
	 * @param playerControls - The control elements for controlling the sorting algorithm's steps.
	 * @param debuggerControls - The control elements for the debugger, controlling the sorting algorithm's code steps.
	 * @param debuggerController - The controller responsible for managing the debugger UI.
	 * @param continuousControls - The controller responsible for managing the UI and state of continuous controls (playing).
	 * @param stepKindController - The controller responsible for keeping track of the currently selected StepKind.
	 * @param htmlDisplayHandlers - The handlers for updating parts of the HTML document with the current state of the sorting algorithm.
	 * @param svgDisplayHandler - The handler for displaying the state of the algorithm in SVG image.
	 * @param renderers - The SVG renderers available for the given algorithm.
	 * @param colors - The color settings for the page.
	 * @param resetButton - The button element for resetting the state of the sorting algorithm.
	 *
	 * @see {@link ContinuousControlController}
	 * @see {@link StepKind}
	 * @see {@link StepKindController}
	 * @see {@link StepDisplayHandler}
	 * @see {@link SvgRenderer}
	 * @see {@link PageColors}
	 */
	public constructor(
		private readonly algorithm: SortingAlgorithm,
		private readonly stepController: StepController,
		private readonly debuggerController: DebuggerController,
		private readonly continuousControls: ContinuousControlController,
		private readonly stepKindController: StepKindController,
		private readonly htmlDisplayHandlers: readonly StepDisplayHandler[],
		private readonly svgDisplayHandler: HtmlSvgDisplayHandler,
		private readonly visualizationOptionsController: VisualizationOptionsController,
		public readonly colors: PageColors,
		private readonly resetButton: HTMLButtonElement
	) {
		this.steps = new StepResultCollection(this.algorithm.getInitialStepResult());

		this.debuggerController.setCode(algorithm.getPseudocode());

		this.reset();

		this.stepController.registerHandler((stepKind, stepAction) => this.stepHandler(stepKind, stepAction));

		this.resetButton.addEventListener("click", () => this.reset());

		this.continuousControls.addEventListenerPlay((kind, intervalMs) => this.play(kind, intervalMs, true));
		this.continuousControls.addEventListenerPause(() => this.pause(true));
		this.continuousControls.addEventListenerTick((kind) => this.forward(kind));

		this.currentColorMap = colors.currentColorMap;

		this.svgDisplayHandler.animate = this.visualizationOptionsController.animationsEnabled;
		const renderer = this.visualizationOptionsController.currentRenderer;
		if (renderer != null) {
			this.svgDisplayHandler.updateRenderer(renderer);
		}

		this.visualizationOptionsController.registerAnimationsChangedHandler(enabled => this.svgDisplayHandler.animate = enabled);
		this.visualizationOptionsController.registerRendererChangedHandler(newRenderer => {
			if (newRenderer != null) {
				this.svgDisplayHandler.updateRenderer(newRenderer);
			}
		});

		this.setRangeOfValues();
	}

	private stepHandler(stepKind: StepKind, stepAction: StepAction): void {
		switch (stepAction) {
			case StepAction.Backward: this.backward(stepKind); break;
			case StepAction.Forward: this.forward(stepKind); break;
			case StepAction.ToBeginning: this.toBeginning(); break;
			case StepAction.ToEnd: this.toEnd(); break;
		}
	}

	/**
	 * Draws the current state of the sorting process.
	 */
	public draw(): void {
		const currentState = this.steps.currentState;
		const currentStepNumbers = currentState.index;

		for (const handler of this.htmlDisplayHandlers) {
			handler.display(currentState.step);
		}
		this.svgDisplayHandler.display(currentState.step);

		this.stepController.currentStep = currentStepNumbers;
		if (this.stepController.finalStep != this.steps.finalStepIndexes) {
			this.stepController.finalStep = this.steps.finalStepIndexes;
		}
	}

	/**
	 * Redraws the elements after events such as resize (if the elements need to react to such events).
	 */
	public redraw(): void {
		for (const handler of this.htmlDisplayHandlers) {
			handler.redraw();
		}

		this.svgDisplayHandler.redraw();
	}

	/**
	 * Advances the sorting process by one step.
	 * @param kind - The kind of step to advance (defaults to the step kind currently selected by the stepKindController passed to the constructor).
	 * @see {@link StepKindController}
	 */
	public forward(kind: StepKind = this.stepKindController.selectedStepKind): void {
		if (this.steps.forward(kind))
			this.draw();
		else {
			if (!this.algorithm.completed) {
				if (kind == StepKind.Code)
					this.steps.addAndAdvance(this.algorithm.stepForward(kind));
				else {
					let results = this.algorithm.stepForward(kind);

					results.forEach(stepResult => this.steps.add(stepResult));
					this.steps.goToLastKnownStep();
				}

				this.draw();
			}
		}

		this.updateStepControls();
	}

	/**
	 * Moves the sorting process backward by one step.
	 * @param kind - The kind of step to move backward (defaults to the step kind currently selected by the stepKindController passed to the constructor).
	 * @see {@link StepKindController}
	 */
	public backward(kind: StepKind = this.stepKindController.selectedStepKind): void {
		if (this.steps.backward(kind))
			this.draw();

		this.updateStepControls();
	}

	/**
	 * Moves the sorting algorithm to the initial (beginning) state, without resetting it (keeps already finished steps in memory).
	 */
	public toBeginning(): void {
		this.steps.goToStep(0);

		this.draw();
		this.updateStepControls();
	}

	/**
	 * Moves the sorting algorithm to final (end) state.
	 */
	public toEnd(): void {
		let endStepNumber = this.steps.finalStepIndexes;

		if (endStepNumber != null) {
			this.steps.goToStep(endStepNumber.code);
		}
		else {
			while (!this.algorithm.completed) {
				let result = this.algorithm.stepForward();
				this.steps.add(result);
			}

			this.steps.goToStep(this.steps.getLastKnownStepNumber());
		}

		this.draw();
		this.updateStepControls();
	}

	/**
	 * Updates the state of the elements used to control stepping.
	 */
	private updateStepControls(): void {
		let endStep = this.steps.finalStepIndexes?.code;
		let currentStep = this.steps.currentStepIndexes.code;

		if (this.continuousControls.playing) {
			this.stepController.setDisabled(true);

			if (currentStep == endStep)
				this.pause();
		}
		else {
			if (currentStep == endStep) {
				this.stepController.setDisabled(true, StepAction.Forward);
				this.stepController.setDisabled(true, StepAction.ToEnd);

				this.continuousControls.playButton.disabled = true;
			}
			else {
				this.stepController.setDisabled(false, StepAction.Forward);
				this.stepController.setDisabled(false, StepAction.ToEnd);

				this.continuousControls.playButton.disabled = false;
			}

			if (currentStep <= 0) {
				this.stepController.setDisabled(true, StepAction.Backward);
				this.stepController.setDisabled(true, StepAction.ToBeginning);
			}
			else {
				this.stepController.setDisabled(false, StepAction.Backward);
				this.stepController.setDisabled(false, StepAction.ToBeginning);
			}
		}
	}

	/**
	 * Starts playing (continuously stepping forward) the sorting algorithm.
	 * @param kind - The kind of step to play (defaults to the step kind currently selected by the stepKindController passed to the constructor).
	 * @param intervalMs - The interval in milliseconds between steps (defaults to the current value of the period input in the continuousControlController).
	 * @param triggeredByHandler - Whether the play action was triggered by a handler or manually. If calling the method manually, pwease weave this as false UwU.
	 */
	public play(
		kind: StepKind = this.stepKindController.selectedStepKind,
		intervalMs?: number,
		triggeredByHandler: boolean = false
	): void {
		if (!triggeredByHandler) {
			this.continuousControls.play(kind, intervalMs);
			return;
		}

		this.forward(kind);
	}

	/**
	 * Pauses the playing of the sorting algorithm.
	 * @param triggeredByHandler - Whether the pause action was triggered by a handler. If calling the method manually, pwease weave this as false UwU.
	 */
	public pause(triggeredByHandler: boolean = false): void {
		if (!triggeredByHandler) {
			this.continuousControls.pause();
			return;
		}

		this.stepController.setDisabled(false);

		// update step controls after enabling all of them
		this.updateStepControls();
	}

	/**
	 * Resets the sorting algorithm to its initial state.
	 * Unlike toBeginning, this method resets the sorting algorithm and clears all completed steps from the memory.
	 */
	public reset(): void {
		if (this.continuousControls.playing) {
			this.pause();
		}

		this.algorithm.reset();

		this.steps = new StepResultCollection(this.algorithm.getInitialStepResult());

		this.draw();

		this.updateStepControls();
	}

	/**
	 * Sets the input array for the sorting algorithm.
	 * @param input - The input array.
	 */
	public setInput(input: number[]): void {
		this.algorithm.setInput(input);

		this.setRangeOfValues();

		this.reset();
	}

	/**
	 * Sets the range of array values to all available renderers.
	 */
	private setRangeOfValues(): void {
		const rangeOfValues = this.algorithm.rangeOfValues;

		for (const renderer of this.visualizationOptionsController.renderers) {
			if (supportsRange(renderer[1])) {
				renderer[1].setRangeOfValues(rangeOfValues[0], rangeOfValues[1]);
			}
		}
	}

	/**
	 * Sets the dark or light mode for the UI.
	 * @param darkMode - True to switch to the dark mode, false to switch to the light mode.
	 */
	public setDarkMode(darkMode: boolean): void {
		const newColorMap = darkMode ? this.colors.darkColors : this.colors.lightColors;

		if (this.currentColorMap != newColorMap) {
			this.currentColorMap = newColorMap;

			this.svgDisplayHandler.updateColorMap(newColorMap);
		}
	}

	/**
	 * Performs an action based on the given interface action.
	 * @param action - The interface action to perform.
	 */
	public performAction(action: InterfaceAction): void {
		const actionInfo = InterfaceActionData.getActionInfo(action);

		switch (actionInfo.group) {
			case InterfaceActionGroup.Backward:
				if (actionInfo.stepKind != undefined)
					this.backward(actionInfo.stepKind);
				else
					this.backward();
				break;
			case InterfaceActionGroup.Forward:
				if (actionInfo.stepKind != undefined)
					this.forward(actionInfo.stepKind);
				else
					this.forward();
				break;
			case InterfaceActionGroup.Select:
				if (actionInfo.stepKind != undefined) {
					this.stepKindController.selectedStepKind = actionInfo.stepKind;
				} else {
					switch (action) {
						case InterfaceAction.Select_Next:
							this.stepKindController.selectNextInLine(true);
							break;
						case InterfaceAction.Select_Previous:
							this.stepKindController.selectNextInLine(false);
							break;
					}
				}
				break;
			case InterfaceActionGroup.PlayPause:
				if (this.playing)
					this.pause();
				else
					this.play();
				break;
		}
	}
}