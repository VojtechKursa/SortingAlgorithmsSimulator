import { SortingAlgorithm } from "../sorts/SortingAlgorithm";
import { StepResultCollection } from "../data/collections/StepResultCollection";
import { RendererControlElements } from "../data/collections/htmlElementCollections/RendererControlElements";
import { DebuggerControlElements } from "../data/collections/htmlElementCollections/DebuggerControlElements";
import { StepKind } from "../data/stepResults/StepKind";
import { ContinuousControlController } from "./ContinuousControlController";
import { StepDisplayHandler } from "../visualization/rendering/StepDisplayHandler";
import { PageColors } from "../visualization/colors/PageColors";
import { FullStepResult } from "../data/stepResults/FullStepResult";
import { ColorSet } from "../visualization/colors/ColorSet";
import { DebuggerController } from "./DebuggerController";
import { StepKindController } from "./StepKindController";
import { InterfaceAction, InterfaceActionGroup, InterfaceActionData } from "../keyboard/InterfaceAction";
import { HtmlSvgDisplayHandler } from "../visualization/rendering/html/HtmlSvgDisplayHandler";
import { SvgRenderer } from "../visualization/rendering/SvgRenderer";

/**
 * The PlayerController class for managing the interaction between the user interface and the sorting algorithm.
 * It handles user inputs, maintains correct state of the simulator-related UI elements and controls the flow of the sorting algorithm.
 */
export class PlayerController {
	/**
	 * The currently displayed full step result in the sorting process.
	 * This is used to track the current state of the sorting algorithm's full step.
	 */
	private currentlyDisplayedFullStep: FullStepResult | null = null;

	/**
	 * A collection of step results generated by the sorting algorithm.
	 * Used as a memory, to allow easy stepping backwards and to navigate through the steps of the sorting algorithm easily.
	 */
	private steps: StepResultCollection;

	/**
	 * The current color set being used for the UI.
	 */
	private currentColorSet: ColorSet;

	/**
	 * Indicates whether the sorting algorithms is currently playing (continuously stepping forward).
	 */
	public get playing(): boolean {
		return this.continuousControls.playing;
	}

	/**
	 * Indicates whether a text field is currently focused.
	 * Used for the purposes of rejecting keyboard events when a text field is focused.
	 */
	public get textFieldFocused(): boolean {
		return window.document.activeElement == this.continuousControls.periodInput;
	}

	/**
	 * @param algorithm - The sorting algorithm to be controlled.
	 * @param playerControls - The control elements for controlling the sorting algorithm's steps.
	 * @param debuggerControls - The control elements for the debugger, controlling the sorting algorithm's code steps.
	 * @param debuggerController - The controller responsible for managing the debugger UI.
	 * @param continuousControls - The controller responsible for managing the UI and state of continuous controls (playing).
	 * @param stepKindController - The controller responsible for keeping track of the currently selected StepKind.
	 * @param htmlDisplayHandlers - The handlers for updating parts of the HTML document with the current state of the sorting algorithm.
	 * @param svgDisplayHandler - The handler for displaying the state of the algorithm in SVG image.
	 * @param renderers - The SVG renderers available for the given algorithm.
	 * @param colors - The color settings for the page.
	 * @param resetButton - The button element for resetting the state of the sorting algorithm.
	 *
	 * @see {@link ContinuousControlController}
	 * @see {@link StepKind}
	 * @see {@link StepKindController}
	 * @see {@link StepDisplayHandler}
	 * @see {@link SvgRenderer}
	 * @see {@link PageColors}
	 */
	public constructor(
		private readonly algorithm: SortingAlgorithm,
		private readonly playerControls: RendererControlElements,
		private readonly debuggerControls: DebuggerControlElements,
		private readonly debuggerController: DebuggerController,
		private readonly continuousControls: ContinuousControlController,
		private readonly stepKindController: StepKindController,
		private readonly htmlDisplayHandlers: readonly StepDisplayHandler[],
		private readonly svgDisplayHandler: HtmlSvgDisplayHandler,
		private readonly renderers: readonly SvgRenderer[],
		public readonly colors: PageColors,
		private readonly resetButton: HTMLButtonElement
	) {
		this.steps = new StepResultCollection(this.algorithm.getInitialStepResult());

		this.debuggerController.setCode(algorithm.getPseudocode());

		this.reset();

		this.playerControls.backFullStepButton.addEventListener("click", _ => this.backward(StepKind.Full));
		this.playerControls.forwardFullStepButton.addEventListener("click", _ => this.forward(StepKind.Full));
		this.playerControls.backSubStepButton.addEventListener("click", _ => this.backward(StepKind.Sub));
		this.playerControls.forwardSubStepButton.addEventListener("click", _ => this.forward(StepKind.Sub));
		this.playerControls.beginningButton.addEventListener("click", _ => this.toBeginning());
		this.playerControls.endButton.addEventListener("click", _ => this.toEnd());

		this.debuggerControls.backCodeStepButton.addEventListener("click", _ => this.backward(StepKind.Code));
		this.debuggerControls.forwardCodeStepButton.addEventListener("click", _ => this.forward(StepKind.Code));

		this.resetButton.addEventListener("click", _ => this.reset());

		this.continuousControls.addEventListenerPlay((kind, intervalMs) => this.play(kind, intervalMs, true));
		this.continuousControls.addEventListenerPause(() => this.pause(true));
		this.continuousControls.addEventListenerTick((kind) => this.forward(kind));

		this.currentColorSet = colors.currentColorSet;
	}

	/**
	 * Draws the current state of the sorting process.
	 */
	public draw(): void {
		let currentState = this.steps.getCurrentStep();
		let currentStepNumbers = currentState.stepsIndex;

		let fullStep: FullStepResult | undefined = undefined;
		if (currentState.fullStepResult != this.currentlyDisplayedFullStep) {
			fullStep = currentState.fullStepResult;
			this.currentlyDisplayedFullStep = currentState.fullStepResult;
		}

		for (const handler of this.htmlDisplayHandlers) {
			handler.display(fullStep, currentState.codeStepResult);
		}
		this.svgDisplayHandler.display(fullStep, currentState.codeStepResult);

		let endStepNumberFull = this.steps.getEndStepNumber(StepKind.Full);
		let endStepNumberSub = this.steps.getEndStepNumber(StepKind.Sub);
		this.playerControls.stepOutput.innerHTML = `${currentStepNumbers.full}<sub>${currentStepNumbers.sub + 1} / ${endStepNumberSub == null ? "?" : endStepNumberSub + 1}</sub> / ${endStepNumberFull == null ? "?" : endStepNumberFull}`;

		let endStepNumberCode = this.steps.getEndStepNumber(StepKind.Code);
		this.debuggerControls.stepOutput.value = `${currentStepNumbers.code} / ${endStepNumberCode == null ? "?" : endStepNumberCode}`;
	}

	/**
	 * Redraws the elements after events such as resize (if the elements need to react to such events).
	 */
	public redraw(): void {
		for (const handler of this.htmlDisplayHandlers) {
			handler.redraw();
		}

		this.svgDisplayHandler.redraw();
	}

	/**
	 * Advances the sorting process by one step.
	 * @param kind - The kind of step to advance (defaults to the step kind currently selected by the stepKindController passed to the constructor).
	 * @see {@link StepKindController}
	 */
	public forward(kind: StepKind = this.stepKindController.selectedStepKind): void {
		if (this.steps.forward(kind))
			this.draw();
		else {
			if (!this.algorithm.isCompleted()) {
				if (kind == StepKind.Code)
					this.steps.addAndAdvance(this.algorithm.stepForward(kind));
				else {
					let results = this.algorithm.stepForward(kind);

					results.forEach(stepResult => this.steps.add(stepResult));
					this.steps.goToLastKnownStep();
				}

				this.draw();
			}
		}

		this.updateStepControls();
	}

	/**
	 * Moves the sorting process backward by one step.
	 * @param kind - The kind of step to move backward (defaults to the step kind currently selected by the stepKindController passed to the constructor).
	 * @see {@link StepKindController}
	 */
	public backward(kind: StepKind = this.stepKindController.selectedStepKind): void {
		if (this.steps.backward(kind))
			this.draw();

		this.updateStepControls();
	}

	/**
	 * Moves the sorting algorithm to the initial (beginning) state, without resetting it (keeps already finished steps in memory).
	 */
	public toBeginning(): void {
		this.steps.goToStep(0);

		this.draw();
		this.updateStepControls();
	}

	/**
	 * Moves the sorting algorithm to final (end) state.
	 */
	public toEnd(): void {
		let endStepNumber = this.steps.getEndStepNumber();

		if (endStepNumber != null) {
			this.steps.goToStep(endStepNumber);
		}
		else {
			while (!this.algorithm.isCompleted()) {
				let result = this.algorithm.stepForward();
				this.steps.add(result);
			}

			this.steps.goToStep(this.steps.getLastKnownStepNumber());
		}

		this.draw();
		this.updateStepControls();
	}

	/**
	 * Updates the state of the elements used to control stepping.
	 */
	private updateStepControls(): void {
		let endStep = this.steps.getEndStepNumber();
		let currentStep = this.steps.getCurrentStepNumbers().code;

		if (this.continuousControls.playing) {
			this.disableAllDirectStepControls(true);

			if (currentStep == endStep)
				this.pause();
		}
		else {
			if (currentStep == endStep) {
				this.playerControls.forwardFullStepButton.disabled = true;
				this.playerControls.forwardSubStepButton.disabled = true;
				this.playerControls.endButton.disabled = true;

				this.debuggerControls.forwardCodeStepButton.disabled = true;

				this.continuousControls.playButton.disabled = true;
			}
			else if (this.playerControls.forwardFullStepButton.disabled) {
				this.playerControls.forwardFullStepButton.disabled = false;
				this.playerControls.forwardSubStepButton.disabled = false;
				this.playerControls.endButton.disabled = false;

				this.debuggerControls.forwardCodeStepButton.disabled = false;

				this.continuousControls.playButton.disabled = false;
			}

			if (currentStep <= 0) {
				this.playerControls.backFullStepButton.disabled = true;
				this.playerControls.backSubStepButton.disabled = true;
				this.playerControls.beginningButton.disabled = true;

				this.debuggerControls.backCodeStepButton.disabled = true;
			}
			else if (this.playerControls.backFullStepButton.disabled) {
				this.playerControls.backFullStepButton.disabled = false;
				this.playerControls.backSubStepButton.disabled = false;
				this.playerControls.beginningButton.disabled = false;

				this.debuggerControls.backCodeStepButton.disabled = false;
			}
		}
	}

	/**
	 * Enables or disables all direct step control buttons.
	 * @param disabled - Whether to disable the buttons.
	 */
	private disableAllDirectStepControls(disabled: boolean): void {
		this.playerControls.forwardFullStepButton.disabled = disabled;
		this.playerControls.forwardSubStepButton.disabled = disabled;
		this.playerControls.endButton.disabled = disabled;
		this.debuggerControls.forwardCodeStepButton.disabled = disabled;

		this.playerControls.backFullStepButton.disabled = disabled;
		this.playerControls.backSubStepButton.disabled = disabled;
		this.playerControls.beginningButton.disabled = disabled;
		this.debuggerControls.backCodeStepButton.disabled = disabled;
	}

	/**
	 * Starts playing (continuously stepping forward) the sorting algorithm.
	 * @param kind - The kind of step to play (defaults to the step kind currently selected by the stepKindController passed to the constructor).
	 * @param intervalMs - The interval in milliseconds between steps (defaults to the current value of the period input in the continuousControlController).
	 * @param triggeredByHandler - Whether the play action was triggered by a handler or manually. If calling the method manually, pwease weave this as false UwU.
	 */
	public play(
		kind: StepKind = this.stepKindController.selectedStepKind,
		intervalMs?: number,
		triggeredByHandler: boolean = false
	): void {
		if (!triggeredByHandler) {
			this.continuousControls.play(kind, intervalMs);
			return;
		}

		this.forward(kind);
	}

	/**
	 * Pauses the playing of the sorting algorithm.
	 * @param triggeredByHandler - Whether the pause action was triggered by a handler. If calling the method manually, pwease weave this as false UwU.
	 */
	public pause(triggeredByHandler: boolean = false): void {
		if (!triggeredByHandler) {
			this.continuousControls.pause();
			return;
		}

		this.disableAllDirectStepControls(false);

		// update step controls after enabling all of them
		this.updateStepControls();
	}

	/**
	 * Resets the sorting algorithm to its initial state.
	 * Unlike toBeginning, this method resets the sorting algorithm and clears all completed steps from the memory.
	 */
	public reset(): void {
		if (this.continuousControls.playing) {
			this.pause();
		}

		this.algorithm.reset();

		this.steps = new StepResultCollection(this.algorithm.getInitialStepResult());

		this.draw();

		this.updateStepControls();
	}

	/**
	 * Sets the input array for the sorting algorithm.
	 * @param input - The input array.
	 */
	public setInput(input: number[]): void {
		this.algorithm.setInput(input);

		this.reset();
	}

	/**
	 * Sets the dark or light mode for the UI.
	 * @param darkMode - True to switch to the dark mode, false to switch to the light mode.
	 */
	public setDarkMode(darkMode: boolean): void {
		const newColorSet = darkMode ? this.colors.darkColors : this.colors.lightColors;

		if (this.currentColorSet != newColorSet) {
			this.currentColorSet = newColorSet;

			this.svgDisplayHandler.updateColorSet(newColorSet);
		}
	}

	/**
	 * Performs an action based on the given interface action.
	 * @param action - The interface action to perform.
	 */
	public performAction(action: InterfaceAction): void {
		const actionInfo = InterfaceActionData.getActionInfo(action);

		switch (actionInfo.group) {
			case InterfaceActionGroup.Backward:
				if (actionInfo.stepKind != undefined)
					this.backward(actionInfo.stepKind);
				else
					this.backward();
				break;
			case InterfaceActionGroup.Forward:
				if (actionInfo.stepKind != undefined)
					this.forward(actionInfo.stepKind);
				else
					this.forward();
				break;
			case InterfaceActionGroup.Select:
				if (actionInfo.stepKind != undefined) {
					this.stepKindController.selectedStepKind = actionInfo.stepKind;
				} else {
					switch (action) {
						case InterfaceAction.Select_Next:
							this.stepKindController.selectNextInLine(true);
							break;
						case InterfaceAction.Select_Previous:
							this.stepKindController.selectNextInLine(false);
							break;
					}
				}
				break;
			case InterfaceActionGroup.PlayPause:
				if (this.playing)
					this.pause();
				else
					this.play();
				break;
		}
	}
}