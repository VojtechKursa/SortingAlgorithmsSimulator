import { StepIndexes } from "../data/StepIndexes";
import { StepKind, StepKindHelper } from "../data/stepResults/StepKind";
import { StepControllerClasses } from "../visualization/css/StepControllerClasses";

/**
 * Represents possible stepping actions.
 */
export const enum StepAction {
	Forward,
	Backward,
	ToBeginning,
	ToEnd
}

/**
 * Represents a handler for step events.
 * @param stepKind - The kind of the step that the event is related to.
 * @param stepAction - The action that was performed.
 */
export interface StepEventHandler { (stepKind: StepKind, stepAction: StepAction): void }

/**
 * Represents a handler for step events generated by {@link StepControllerElementary}.
 * @param stepKind - The kind of the step that the event is related to.
 * @param stepAction - The action that was performed.
 * @param controller - The controller that generated the event.
 */
interface StepEventHandlerElementary { (stepKind: StepKind, stepAction: StepAction, controller: StepControllerElementary): void }

/**
 * An elementary step controller for a single kind of step.
 */
class StepControllerElementary {
	/**
	 * Button for moving to the previous step.
	 */
	private readonly backButton: HTMLButtonElement;

	/**
	 * Button for moving to the next step.
	 */
	private readonly nextButton: HTMLButtonElement;

	/**
	 * Output element displaying the current step.
	 */
	private readonly stepDisplay: HTMLOutputElement;

	/**
	 * The current step number.
	 */
	private _currentStep: number = 0;

	/**
	 * The final step number.
	 */
	private _finalStep: number | undefined;

	/**
	 * The symbol to display instead of an unknown final step number.
	 */
	private _unknownSymbol: string;

	/**
	 * The event handlers for step events generated by this controller.
	 */
	private readonly eventHandlers: StepEventHandlerElementary[] = [];

	/**
	 * @param wrapper - The wrapper element for the UI elements of the controller.
	 * @param stepKind - The kind of the step that this controller is responsible for.
	 * @param unknownSymbol - The symbol to display instead of an unknown final step number.
	 */
	public constructor(
		public readonly wrapper: HTMLDivElement,
		public readonly stepKind: StepKind,
		unknownSymbol: string = "?"
	) {
		this._unknownSymbol = unknownSymbol;

		wrapper.classList.add(StepControllerClasses.wrapperClass);

		const buttonGroup = document.createElement("div");
		buttonGroup.classList.add("btn-group");
		buttonGroup.role = "group";

		this.backButton = document.createElement("button");
		const backIcon = document.createElement("i");
		backIcon.classList.add("bi", "bi-caret-left-fill");
		this.backButton.appendChild(backIcon);

		this.nextButton = document.createElement("button");
		const nextIcon = document.createElement("i");
		nextIcon.classList.add("bi", "bi-caret-right-fill");
		this.nextButton.appendChild(nextIcon);

		for (const button of [this.backButton, this.nextButton]) {
			button.classList.add("btn", "btn-primary");
			button.type = "button";
		}

		this.stepDisplay = document.createElement("output");
		this.stepDisplay.classList.add("disabled");

		const label = document.createElement("div");
		label.textContent = `${StepKindHelper.toString(stepKind).displayName.charAt(0)}:`;
		label.classList.add(StepControllerClasses.labelClass);
		label.title = StepKindHelper.toString(stepKind).displayName;

		buttonGroup.appendChild(this.backButton);
		buttonGroup.appendChild(this.stepDisplay);
		buttonGroup.appendChild(this.nextButton);

		wrapper.appendChild(label);
		wrapper.appendChild(buttonGroup);

		this.backButton.addEventListener("click", () => {
			for (const handler of this.eventHandlers) {
				handler(this.stepKind, StepAction.Backward, this);
			}
		});

		this.nextButton.addEventListener("click", () => {
			for (const handler of this.eventHandlers) {
				handler(this.stepKind, StepAction.Forward, this);
			}
		});
	}

	/**
	 * The current step number.
	 */
	public get currentStep(): number {
		return this._currentStep;
	}
	public set currentStep(value: number) {
		this._currentStep = value;
		this.update();
	}

	/**
	 * The final step number.
	 */
	public get finalStep(): number | undefined {
		return this._finalStep;
	}
	public set finalStep(value: number | undefined | null) {
		if (value == null)
			value = undefined;

		this._finalStep = value;
		this.update();
	}

	/**
	 * The symbol to display instead of an unknown final step number.
	 */
	public get unknownSymbol(): string {
		return this._unknownSymbol;
	}
	public set unknownSymbol(value: string) {
		this._unknownSymbol = value;
		this.update();
	}

	/**
	 * Updates both the current and final step in a single operation (resulting in only one update).
	 */
	public updateSteps(currentStep: number, finalStep: number | undefined | null): void {
		if (finalStep == null)
			finalStep = undefined;

		this._currentStep = currentStep;
		this._finalStep = finalStep;

		this.update();
	}

	/**
	 * Get the disabled state of the controller's control buttons.
	 * @param stepAction The action whose corresponding button to check the disabled state of. If undefined, returns true if any of the buttons are disabled.
	 * @returns
	 * 	Whether the control button corresponding to the specified {@link stepAction} is disabled.
	 * 	If {@link stepAction} is undefined, returns true if any of the buttons are disabled.
	 */
	public getDisabled(stepAction?: StepAction): boolean {
		if (stepAction == undefined)
			return this.nextButton.disabled || this.backButton.disabled;

		switch (stepAction) {
			case StepAction.Backward:
			case StepAction.ToBeginning:
				return this.backButton.disabled;
			case StepAction.Forward:
			case StepAction.ToEnd:
				return this.nextButton.disabled;
		}
	}

	/**
	 * Set the disabled state of the controller's control buttons.
	 * @param disabled Whether to disable the control buttons.
	 * @param stepAction The action whose corresponding button to set the disabled state of. If undefined, sets the disabled state of both buttons.
	 */
	public setDisabled(disabled: boolean, stepAction?: StepAction): void {
		if (stepAction == undefined) {
			this.nextButton.disabled = disabled;
			this.backButton.disabled = disabled;
		}
		else if (stepAction == StepAction.Forward) {
			this.nextButton.disabled = disabled;
		}
		else if (stepAction == StepAction.Backward) {
			this.backButton.disabled = disabled;
		}
	}

	/**
	 * Updates the displayed step numbers.
	 */
	private update(): void {
		this.stepDisplay.textContent = `${this.currentStep} / ${this.finalStep ?? this.unknownSymbol}`;
	}

	/**
	 * Registers a handler for step events generated by this controller.
	 * @param handler The handler to register.
	 */
	public registerHandler(handler: StepEventHandlerElementary): void {
		this.eventHandlers.push(handler);
	}

	/**
	 * Un-registers a handler for step events generated by this controller.
	 * @param handler The handler to unregister.
	 */
	public unregisterHandler(handler: StepEventHandlerElementary): void {
		let index = this.eventHandlers.findIndex(val => val == handler);

		while (index != -1) {
			this.eventHandlers.splice(index, 1);

			index = this.eventHandlers.findIndex(val => val == handler);
		}
	}
}

/**
 * A controller class responsible for control of stepping operations in the simulator.
 */
export class StepController {
	/**
	 * The controllers for each kind of step.
	 */
	private readonly stepControllers: readonly StepControllerElementary[];

	/**
	 * The event handlers for step events generated by this controller.
	 */
	private readonly eventHandlers: StepEventHandler[] = [];

	/**
	 * Button for moving to the beginning of the algorithm.
	 */
	private readonly beginningButton: HTMLButtonElement;

	/**
	 * Button for moving to the end of the algorithm.
	 */
	private readonly endButton: HTMLButtonElement;

	/**
	 * The current step indexes.
	 */
	private _currentStep: StepIndexes;
	/**
	 * The current step indexes.
	 */
	public get currentStep(): StepIndexes {
		return this._currentStep;
	}
	public set currentStep(indexes: StepIndexes) {
		for (const controller of this.stepControllers.values()) {
			const stepCount = indexes.getIndex(controller.stepKind);
			controller.currentStep = stepCount;
		}

		this._currentStep = indexes;
	}

	/**
	 * The final step indexes.
	 */
	private _finalStep: StepIndexes | undefined;
	/**
	 * The final step indexes.
	 */
	public get finalStep(): StepIndexes | undefined {
		return this._finalStep;
	}
	public set finalStep(indexes: StepIndexes | undefined | null) {
		if (indexes == null)
			indexes = undefined;

		for (const controller of this.stepControllers.values()) {
			if (indexes != undefined) {
				const stepCount = indexes.getIndex(controller.stepKind);
				controller.finalStep = stepCount;
			}
			else {
				controller.finalStep = undefined;
			}
		}

		this._finalStep = indexes;
	}

	/**
	 * @param rendererStepControllerWrapper - The wrapper element for the controller's control elements in the renderer section of the simulator.
	 * @param debuggerStepControllerWrapper - The wrapper element for the controller's control elements in the debugger section of the simulator.
	 */
	public constructor(
		rendererStepControllerWrapper: HTMLDivElement,
		debuggerStepControllerWrapper: HTMLDivElement
	) {
		// Set initial current step
		this._currentStep = new StepIndexes(0, 0, 0);

		// Vertical wrapper for controllers in the renderer section
		const rendererControllerWrapper = document.createElement("div");
		rendererControllerWrapper.classList.add(StepControllerClasses.verticalWrapperClass);

		const significantWrapper = document.createElement("div");
		const algorithmicWrapper = document.createElement("div");
		rendererControllerWrapper.appendChild(algorithmicWrapper);
		rendererControllerWrapper.appendChild(significantWrapper);

		// Generate controllers
		const generationConfig: [StepKind, HTMLDivElement][] = [
			[StepKind.Code, debuggerStepControllerWrapper],
			[StepKind.Significant, significantWrapper],
			[StepKind.Algorithmic, algorithmicWrapper]
		];

		const controllers: StepControllerElementary[] = [];

		for (const config of generationConfig) {
			const controller = new StepControllerElementary(config[1], config[0]);
			controllers.push(controller);

			controller.registerHandler((stepKind, stepAction) => this.stepHandler(stepKind, stepAction));
		}

		this.stepControllers = controllers;

		// Generate "to beginning" and "to end" buttons
		this.beginningButton = document.createElement("button");
		this.beginningButton.id = "step-beginning";
		const beginningIcon = document.createElement("i");
		beginningIcon.classList.add("bi", "bi-skip-backward-fill");
		this.beginningButton.appendChild(beginningIcon);

		this.endButton = document.createElement("button");
		this.endButton.id = "step-end";
		const endIcon = document.createElement("i");
		endIcon.classList.add("bi", "bi-skip-forward-fill");
		this.endButton.appendChild(endIcon);

		for (const button of [this.beginningButton, this.endButton]) {
			button.classList.add("btn", "btn-primary");
			button.type = "button";
		}

		// Bind onClick event listeners to "to beginning" and "to end" buttons
		this.beginningButton.addEventListener("click", () => this.stepHandler(StepKind.Algorithmic, StepAction.ToBeginning));
		this.endButton.addEventListener("click", () => this.stepHandler(StepKind.Algorithmic, StepAction.ToEnd));

		// Append renderer section elements to the DOM
		rendererStepControllerWrapper.appendChild(this.beginningButton);
		rendererStepControllerWrapper.appendChild(rendererControllerWrapper);
		rendererStepControllerWrapper.appendChild(this.endButton);
	}

	/**
	 * Handles a step event from an underlying controller.
	 * @param stepKind - The kind of the step that is to be performed.
	 * @param stepAction - The step action that is to be performed.
	 */
	private stepHandler(stepKind: StepKind, stepAction: StepAction) {
		for (const handler of this.eventHandlers) {
			handler(stepKind, stepAction);
		}
	}

	/**
	 * Get the disabled state of the controller's control buttons.
	 * @param stepAction The action whose corresponding button to check the disabled state of. If undefined, returns true if any of the buttons are disabled.
	 * @param stepKind The kind of step whose corresponding buttons to check. If undefined, checks all underlying controllers.
	 * @returns Whether the control button(s) corresponding to the specified {@link stepAction} and {@link stepKind} is/are disabled.
	 */
	public getDisabled(stepAction?: StepAction, stepKind?: StepKind): boolean {
		const toScan = stepKind == undefined ? this.stepControllers : this.stepControllers.filter(controller => controller.stepKind == stepKind);

		for (const controller of toScan) {
			if (controller.getDisabled(stepAction))
				return true;
		}

		return false;
	}

	/**
	 * Set the disabled state of the controller's control buttons.
	 * @param disabled Whether to disable the control buttons.
	 * @param stepAction The action whose corresponding button to set the disabled state of. If undefined, sets the disabled state of all states.
	 * @param stepKind The kind of step whose corresponding buttons to set. If undefined, sets the disabled state of all step kinds.
	 */
	public setDisabled(disabled: boolean, stepAction?: StepAction, stepKind?: StepKind): void {
		if (stepAction == StepAction.ToBeginning || stepAction == undefined) {
			this.beginningButton.disabled = disabled;
			if (stepAction != undefined)
				return;
		}

		if (stepAction == StepAction.ToEnd || stepAction == undefined) {
			this.endButton.disabled = disabled;
			if (stepAction != undefined)
				return;
		}

		const toSet = stepKind == undefined ? this.stepControllers : this.stepControllers.filter(controller => controller.stepKind == stepKind);

		for (const controller of toSet) {
			controller.setDisabled(disabled, stepAction);
		}
	}

	/**
	 * Registers a handler for step events generated by this controller.
	 * @param handler The handler to register.
	 */
	public registerHandler(handler: StepEventHandler): void {
		this.eventHandlers.push(handler);
	}

	/**
	 * Un-registers a handler for step events generated by this controller.
	 * @param handler The handler to unregister.
	 */
	public unregisterHandler(handler: StepEventHandler): void {
		let index = this.eventHandlers.findIndex(val => val == handler);

		while (index != -1) {
			this.eventHandlers.splice(index, 1);

			index = this.eventHandlers.findIndex(val => val == handler);
		}
	}
}